Задача. В Next.js (App Router, TypeScript) реализовать 4 API-эндпойнта для работы с Airtable. Аутентификация кабинета — через httpOnly cookie session_email. Почтовую отправку кода делать только если есть SENDGRID_API_KEY или SMTP_HOST, иначе отвечать {ok:true} и код пришлёт Airtable Automation.

Таблицы и поля в Airtable:

Partners:
email (Email), current_slug (Text), partner_id (Text, опционально), status (Text), access_code (Text)

Applications:
partner_id (Text), referrer (Text), status (Text)

ENV (см. Secrets):
AIRTABLE_API_KEY, AIRTABLE_BASE_ID, AIRTABLE_PARTNERS_TABLE, AIRTABLE_APPLICATIONS_TABLE, SENDGRID_API_KEY (опц.), SMTP_* (опц.), SESSION_SECRET, NEXT_PUBLIC_LANDING_URL.

Эндпойнты:

POST /api/login/request-code
Вход: { email }
Действия: если партнёр не существует — создать в Partners с status=new.
Если задан SENDGRID или SMTP — сгенерировать 6-значный access_code, записать в Partners.access_code и отправить email.
Ответ: { ok:true }.

POST /api/auth/login
Вход: { email, access_code }
Проверка: в Partners запись AND({email}='...', {access_code}='...').
Если ок: очистить access_code, установить httpOnly cookie session_email=<email> на 7 дней, ответ {ok:true}.
Если нет: 401 {error:"invalid_code"}.

GET /api/partner/stats
Требует cookie session_email.
Находит партнёра по email.
Считает записи в Applications по формуле:

bash
Копировать
Редактировать
OR(
  AND({referrer}!='', {referrer}='<current_slug>'),
  AND({partner_id}!='', {partner_id}='<partner_id>')
)
Возвращает { total, byStatus }, где byStatus — объект вида { new: N, verified: M, ... }.

POST /api/partner/new-code
Требует cookie session_email.
Генерирует новый slug (8 символов a-z0-9, без похожих) и пишет в Partners.current_slug.
Ответ: { slug }.

Файлы создать с таким содержимым (не менять пути):

app/api/login/request-code/route.ts

app/api/auth/login/route.ts

app/api/partner/stats/route.ts

app/api/partner/new-code/route.ts

lib/airtable.ts

lib/email.ts

lib/session.ts

Код ниже.

Файлы (вставь 1:1)
lib/airtable.ts
ts
Копировать
Редактировать
// lib/airtable.ts
const API_KEY = process.env.AIRTABLE_API_KEY!;
const BASE_ID = process.env.AIRTABLE_BASE_ID!;
const PARTNERS = process.env.AIRTABLE_PARTNERS_TABLE || "Partners";
const APPS = process.env.AIRTABLE_APPLICATIONS_TABLE || "Applications";

function esc(v: string) {
  // экранирование одинарной кавычки для формулы Airtable
  return (v ?? "").replace(/'/g, "\\'");
}

async function atFetch(path: string, init?: RequestInit) {
  const url = `https://api.airtable.com/v0/${BASE_ID}/${path}`;
  const r = await fetch(url, {
    ...init,
    headers: {
      Authorization: `Bearer ${API_KEY}`,
      "Content-Type": "application/json",
      ...(init?.headers || {}),
    },
    cache: "no-store",
  });
  if (!r.ok) {
    const t = await r.text().catch(() => "");
    throw new Error(`Airtable ${r.status}: ${t}`);
  }
  return r.json();
}

export async function partnersFindOneByEmail(email: string) {
  const ff = encodeURIComponent(`{email}='${esc(email)}'`);
  const data = await atFetch(`${encodeURIComponent(PARTNERS)}?maxRecords=1&filterByFormula=${ff}`);
  return data.records?.[0] || null;
}

export async function partnersCreate(fields: Record<string, any>) {
  const data = await atFetch(encodeURIComponent(PARTNERS), {
    method: "POST",
    body: JSON.stringify({ records: [{ fields }] }),
  });
  return data.records?.[0] || null;
}

export async function partnersUpdate(id: string, fields: Record<string, any>) {
  const data = await atFetch(encodeURIComponent(PARTNERS), {
    method: "PATCH",
    body: JSON.stringify({ records: [{ id, fields }] }),
  });
  return data.records?.[0] || null;
}

export async function appsListByPartner(currentSlug?: string, partnerId?: string) {
  const terms: string[] = [];
  if (currentSlug) terms.push(`AND({referrer}!='', {referrer}='${esc(currentSlug)}')`);
  if (partnerId) terms.push(`AND({partner_id}!='', {partner_id}='${esc(partnerId)}')`);
  const or = terms.length ? (terms.length === 1 ? terms[0] : `OR(${terms.join(",")})`) : "FALSE()";
  const ff = encodeURIComponent(or);
  const data = await atFetch(`${encodeURIComponent(APPS)}?filterByFormula=${ff}&pageSize=100`);
  return data.records || [];
}
lib/email.ts
ts
Копировать
Редактировать
// lib/email.ts
import sg from "@sendgrid/mail";
import nodemailer from "nodemailer";

export async function sendLoginCode(to: string, code: string) {
  const html = `
    <p>Ваш код для входа: <b>${code}</b></p>
    <p>Код действует 10 минут. Если вы не запрашивали код, просто удалите письмо.</p>
  `;

  if (process.env.SENDGRID_API_KEY) {
    sg.setApiKey(process.env.SENDGRID_API_KEY);
    await sg.send({ to, from: "no-reply@your-domain", subject: "Код для входа", html });
    return;
  }

  if (process.env.SMTP_HOST) {
    const t = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: Number(process.env.SMTP_PORT || 587),
      secure: false,
      auth: process.env.SMTP_USER && process.env.SMTP_PASS ? {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      } : undefined,
    });
    await t.sendMail({ to, from: process.env.SMTP_USER || "no-reply@your-domain", subject: "Код для входа", html });
  }
  // если нет ни SENDGRID, ни SMTP — письмо не шлём (код пришлёт Automation)
}
lib/session.ts
ts
Копировать
Редактировать
// lib/session.ts
import { cookies } from "next/headers";

const COOKIE = "session_email";

export function setSession(email: string) {
  cookies().set(COOKIE, email, {
    httpOnly: true,
    sameSite: "lax",
    secure: true,
    path: "/",
    maxAge: 60 * 60 * 24 * 7, // 7 дней
  });
}

export function clearSession() {
  cookies().set(COOKIE, "", { httpOnly: true, path: "/", maxAge: 0 });
}

export function getSessionEmail(): string | null {
  const c = cookies().get(COOKIE);
  return c?.value || null;
}
app/api/login/request-code/route.ts
ts
Копировать
Редактировать
// app/api/login/request-code/route.ts
import { NextResponse } from "next/server";
import { partnersFindOneByEmail, partnersCreate, partnersUpdate } from "@/lib/airtable";
import { sendLoginCode } from "@/lib/email";

function genCode(n = 6) {
  return Array.from({ length: n }, () => Math.floor(Math.random() * 10)).join("");
}

export async function POST(req: Request) {
  try {
    const { email } = await req.json();
    if (!email || !/^[^@]+@[^@]+\.[^@]+$/.test(email)) {
      return NextResponse.json({ error: "bad_email" }, { status: 400 });
    }

    let rec = await partnersFindOneByEmail(email);
    if (!rec) {
      rec = await partnersCreate({ email, status: "new" });
    } else if (!rec.fields?.status) {
      await partnersUpdate(rec.id, { status: "new" });
    }

    // Если доступна почтовая интеграция — сгенерируем и отправим код сами
    if (process.env.SENDGRID_API_KEY || process.env.SMTP_HOST) {
      const code = genCode(6);
      await partnersUpdate(rec.id, { access_code: code });
      await sendLoginCode(email, code);
    }

    return NextResponse.json({ ok: true });
  } catch (e: any) {
    return NextResponse.json({ error: "server_error", detail: String(e) }, { status: 500 });
  }
}
app/api/auth/login/route.ts
ts
Копировать
Редактировать
// app/api/auth/login/route.ts
import { NextResponse } from "next/server";
import { partnersFindOneByEmail, partnersUpdate } from "@/lib/airtable";
import { setSession } from "@/lib/session";

export async function POST(req: Request) {
  try {
    const { email, access_code } = await req.json();
    if (!email || !access_code) {
      return NextResponse.json({ error: "bad_input" }, { status: 400 });
    }

    const rec = await partnersFindOneByEmail(email);
    const code = rec?.fields?.access_code || "";
    if (!rec || !code || String(code) !== String(access_code)) {
      return NextResponse.json({ error: "invalid_code" }, { status: 401 });
    }

    // очистить код (одноразовый)
    await partnersUpdate(rec.id, { access_code: "" });

    // поставить сессию
    setSession(email);
    return NextResponse.json({ ok: true });
  } catch (e: any) {
    return NextResponse.json({ error: "server_error", detail: String(e) }, { status: 500 });
  }
}
app/api/partner/stats/route.ts
ts
Копировать
Редактировать
// app/api/partner/stats/route.ts
import { NextResponse } from "next/server";
import { getSessionEmail } from "@/lib/session";
import { partnersFindOneByEmail, appsListByPartner } from "@/lib/airtable";

export async function GET() {
  const email = getSessionEmail();
  if (!email) return NextResponse.json({ error: "unauthorized" }, { status: 401 });

  const partner = await partnersFindOneByEmail(email);
  if (!partner) return NextResponse.json({ error: "partner_not_found" }, { status: 404 });

  const slug = partner.fields?.current_slug || "";
  const pid = partner.fields?.partner_id || "";

  const records = await appsListByPartner(slug, pid);

  const byStatus: Record<string, number> = {};
  for (const r of records) {
    const s = (r.fields?.status || "new").toString();
    byStatus[s] = (byStatus[s] || 0) + 1;
  }

  return NextResponse.json({ total: records.length, byStatus });
}
app/api/partner/new-code/route.ts
ts
Копировать
Редактировать
// app/api/partner/new-code/route.ts
import { NextResponse } from "next/server";
import { getSessionEmail } from "@/lib/session";
import { partnersFindOneByEmail, partnersUpdate, partnersCreate } from "@/lib/airtable";

function genSlug(len = 8) {
  const alphabet = "abcdefghijkmnpqrstuvwxyz23456789"; // без 0/O/1/l
  return Array.from({ length: len }, () => alphabet[Math.floor(Math.random() * alphabet.length)]).join("");
}

export async function POST() {
  const email = getSessionEmail();
  if (!email) return NextResponse.json({ error: "unauthorized" }, { status: 401 });

  const slug = genSlug(8);

  let rec = await partnersFindOneByEmail(email);
  if (rec) {
    await partnersUpdate(rec.id, { current_slug: slug });
  } else {
    rec = await partnersCreate({ email, current_slug: slug });
  }

  return NextResponse.json({ slug });
}